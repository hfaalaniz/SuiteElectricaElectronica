using System;
using System.Collections.Generic;
using System.Linq;
using System.Drawing;

namespace BuckConverterCalculator.PCB
{
    /// <summary>
    /// Extrae netlist del esquemático para PCB layout
    /// </summary>
    public class NetlistExtractor
    {
        private object schematicDocument; // SchematicDocument - tipo genérico por ahora

        public NetlistExtractor(object document)
        {
            this.schematicDocument = document;
        }

        /// <summary>
        /// Extrae el netlist completo del esquemático
        /// </summary>
        public List<Net> ExtractNetlist()
        {
            var nets = new Dictionary<string, Net>();
            var wireConnections = FindAllWireConnections();

            int netNumber = 1;

            // Agrupar conexiones en redes
            foreach (var connection in wireConnections)
            {
                string netName = FindOrCreateNet(nets, connection, ref netNumber);
            }

            // Asignar nombres semánticos a las redes importantes
            AssignSemanticNetNames(nets);

            return nets.Values.ToList();
        }

        /// <summary>
        /// Encuentra todas las conexiones de cables en el esquemático
        /// </summary>
        private List<WireConnection> FindAllWireConnections()
        {
            var connections = new List<WireConnection>();

            // TODO: Implementar extracción real desde SchematicDocument
            // Por ahora, devolver lista vacía para compilación

            return connections;
        }

        /// <summary>
        /// Encuentra o crea una red para una conexión
        /// </summary>
        private string FindOrCreateNet(Dictionary<string, Net> nets, WireConnection connection, ref int netNumber)
        {
            // Buscar si algún nodo de esta conexión ya pertenece a una red
            foreach (var net in nets.Values)
            {
                if (net.Nodes.Any(n => NodesAreConnected(n, connection.Node1) ||
                                      NodesAreConnected(n, connection.Node2)))
                {
                    // Agregar nodos a red existente
                    if (!net.Nodes.Any(n => NodesAreConnected(n, connection.Node1)))
                        net.Nodes.Add(connection.Node1);

                    if (!net.Nodes.Any(n => NodesAreConnected(n, connection.Node2)))
                        net.Nodes.Add(connection.Node2);

                    return net.Name;
                }
            }

            // Crear nueva red
            string netName = $"NET{netNumber++}";
            var newNet = new Net
            {
                Name = netName,
                Nodes = new List<NetNode> { connection.Node1, connection.Node2 }
            };

            nets[netName] = newNet;
            return netName;
        }

        /// <summary>
        /// Verifica si dos nodos están conectados (misma posición)
        /// </summary>
        private bool NodesAreConnected(NetNode node1, NetNode node2)
        {
            const int tolerance = 5; // pixels

            return Math.Abs(node1.Position.X - node2.Position.X) <= tolerance &&
                   Math.Abs(node1.Position.Y - node2.Position.Y) <= tolerance;
        }

        /// <summary>
        /// Asigna nombres semánticos a redes especiales (VCC, GND, etc.)
        /// </summary>
        private void AssignSemanticNetNames(Dictionary<string, Net> nets)
        {
            foreach (var net in nets.Values)
            {
                // Buscar componentes especiales en la red
                foreach (var node in net.Nodes)
                {
                    if (node.ComponentName != null)
                    {
                        if (node.ComponentName.StartsWith("VCC") || node.ComponentName.StartsWith("VDD"))
                        {
                            net.Name = "VCC";
                            net.Type = NetType.Power;
                            break;
                        }
                        else if (node.ComponentName.StartsWith("GND") || node.ComponentName == "Ground")
                        {
                            net.Name = "GND";
                            net.Type = NetType.Ground;
                            break;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Exporta netlist a formato SPICE
        /// </summary>
        public void ExportToSPICE(string filename)
        {
            var netlist = ExtractNetlist();

            using (var writer = new System.IO.StreamWriter(filename))
            {
                writer.WriteLine("* SPICE Netlist");
                writer.WriteLine("* Generated by Buck Converter Calculator");
                writer.WriteLine($"* Date: {DateTime.Now}");
                writer.WriteLine();

                // Write components
                writer.WriteLine("* Components");
                foreach (var net in netlist)
                {
                    foreach (var node in net.Nodes)
                    {
                        if (!string.IsNullOrEmpty(node.ComponentName))
                        {
                            writer.WriteLine($"* {node.ComponentName} connected to {net.Name}");
                        }
                    }
                }

                writer.WriteLine();
                writer.WriteLine(".END");
            }
        }

        /// <summary>
        /// Exporta netlist a formato genérico
        /// </summary>
        public void ExportToGenericFormat(string filename)
        {
            var netlist = ExtractNetlist();

            using (var writer = new System.IO.StreamWriter(filename))
            {
                writer.WriteLine("# Netlist Export");
                writer.WriteLine($"# Date: {DateTime.Now}");
                writer.WriteLine();

                foreach (var net in netlist)
                {
                    writer.WriteLine($"Net: {net.Name} (Type: {net.Type})");
                    writer.WriteLine("Connections:");

                    foreach (var node in net.Nodes)
                    {
                        writer.WriteLine($"  - {node.ComponentName}.{node.PinName} at ({node.Position.X}, {node.Position.Y})");
                    }

                    writer.WriteLine();
                }
            }
        }

        /// <summary>
        /// Verifica la integridad del netlist
        /// </summary>
        public NetlistValidationResult ValidateNetlist()
        {
            var result = new NetlistValidationResult { IsValid = true };
            var netlist = ExtractNetlist();

            // Verificar que cada red tenga al menos 2 nodos
            foreach (var net in netlist)
            {
                if (net.Nodes.Count < 2)
                {
                    result.IsValid = false;
                    result.Errors.Add($"Net {net.Name} has only {net.Nodes.Count} node(s)");
                }
            }

            // Verificar que haya al menos una red GND
            if (!netlist.Any(n => n.Type == NetType.Ground))
            {
                result.Warnings.Add("No ground net found");
            }

            // Verificar que haya al menos una red de alimentación
            if (!netlist.Any(n => n.Type == NetType.Power))
            {
                result.Warnings.Add("No power net found");
            }

            return result;
        }
    }

    /// <summary>
    /// Representa una conexión entre dos nodos
    /// </summary>
    internal class WireConnection
    {
        public NetNode Node1 { get; set; }
        public NetNode Node2 { get; set; }
    }

    /// <summary>
    /// Representa una red eléctrica
    /// </summary>
    public class Net
    {
        public string Name { get; set; }
        public NetType Type { get; set; } = NetType.Signal;
        public List<NetNode> Nodes { get; set; } = new List<NetNode>();

        public override string ToString()
        {
            return $"{Name} ({Nodes.Count} nodes)";
        }
    }

    /// <summary>
    /// Tipo de red
    /// </summary>
    public enum NetType
    {
        Signal,
        Power,
        Ground
    }

    /// <summary>
    /// Representa un nodo en una red (pin de componente)
    /// </summary>
    public class NetNode
    {
        public string ComponentName { get; set; }
        public string PinName { get; set; }
        public Point Position { get; set; }

        public override string ToString()
        {
            return $"{ComponentName}.{PinName}";
        }
    }

    /// <summary>
    /// Resultado de validación del netlist
    /// </summary>
    public class NetlistValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new List<string>();
        public List<string> Warnings { get; set; } = new List<string>();

        public string GetReport()
        {
            var report = new System.Text.StringBuilder();

            report.AppendLine(IsValid ? "Netlist is VALID" : "Netlist has ERRORS");
            report.AppendLine();

            if (Errors.Count > 0)
            {
                report.AppendLine("Errors:");
                foreach (var error in Errors)
                {
                    report.AppendLine($"  - {error}");
                }
                report.AppendLine();
            }

            if (Warnings.Count > 0)
            {
                report.AppendLine("Warnings:");
                foreach (var warning in Warnings)
                {
                    report.AppendLine($"  - {warning}");
                }
            }

            return report.ToString();
        }
    }
}